var documenterSearchIndex = {"docs":
[{"location":"FAQs/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"FAQs/#What-is-the-algebraic-structure-of-AlgebraOfGraphics?","page":"Frequently Asked Questions","title":"What is the algebraic structure of AlgebraOfGraphics?","text":"","category":"section"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"AlgebraOfGraphics is based on two operators, + and *. These two operators induce a semiring structure, with a small caveat. Addition is commutative only up to the drawing order. For example, visual(Lines) + visual(Scatter) is slightly different from visual(Scatter) + visual(Lines), in that the former draws the scatter on top of the lines, and the latter draws the lines on top of the scatter. As a consequence, only right distributivity holds with full generality, whereas left distributivity only holds up to the drawing order.","category":"page"},{"location":"FAQs/#Why-is-the-mapping-pair-syntax-different-from-DataFrames?","page":"Frequently Asked Questions","title":"Why is the mapping pair syntax different from DataFrames?","text":"","category":"section"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The transformations passed within a mapping, e.g. mapping(:x => log => \"log(x)\"), are applied element-wise. Operations that require the whole column are not supported on purpose. An important reason to prefer element-wise operations (other than performance) is that whole-column operations can be error prone in this setting, especially when","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"the data is grouped or\ndifferent datasets are used.","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"If you do need column-wise transformations, consider implementing a custom analysis, such as density, which takes the whole data as input, or apply the transformation directly in your data before passing it to AlgebraOfGraphics.","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"See also Pair syntax for a detailed description of the pair syntax within a mapping.","category":"page"},{"location":"FAQs/#What-is-the-difference-between-axis-scales-and-data-transformations?","page":"Frequently Asked Questions","title":"What is the difference between axis scales and data transformations?","text":"","category":"section"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"There are two overlapping but distinct ways to rescale data.","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Keep the data as is and use a nonlinear scale, e.g. axis=(xscale=log,).\nTransform the data directly, e.g. mapping(:x => log => \"log(x)\").","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Note that the resulting plots may \"look different\" in some cases. Consider for instance the following example.","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using AlgebraOfGraphics\nusing AlgebraOfGraphics: density\ndf = (x = exp.(randn(1000)),)\nkde1 = data(df) * mapping(:x) * density()\ndraw(kde1, axis=(width=225, height=225, xscale=log,))","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"df = (x = exp.(randn(1000)),)\nkde2 = data(df) * mapping(:x => log => \"log(x)\") * density()\ndraw(kde2, axis=(width=225, height=225))","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The two plots look different. The first represents the pdf of x in a log scale, while the second represents the pdf of log(x) in a linear scale. The two curves differ by a factor 1 / x, the derivative of log(x). See e.g. this post for some mathematical background on the topic.","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In general, the second approach (plotting the density of log(x)) could be considered more principled, as it preserves the proportionality between area and probability mass. On the contrary, the first approach (plotting the density of x in a log scale) breaks this proportionality relationship.","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"A similar reasoning applies to histograms:","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using AlgebraOfGraphics\ndf = (x = exp.(rand(1000)),)\nhist1 = data(df) * mapping(:x) * histogram()\ndraw(hist1, axis=(width=225, height=225, xscale=log))","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"df = (x = exp.(rand(1000)),)\nhist2 = data(df) * mapping(:x => log => \"log(x)\") * histogram()\ndraw(hist2, axis=(width=225, height=225))","category":"page"},{"location":"FAQs/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"The data transformation approach is preferable as it produces uniform bins, which are easier to interpret.","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/datatransformations.jl\"","category":"page"},{"location":"generated/datatransformations/#Data-Transformations","page":"Data Transformations","title":"Data Transformations","text":"","category":"section"},{"location":"generated/datatransformations/#Histogram","page":"Data Transformations","title":"Histogram","text":"","category":"section"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"histogram","category":"page"},{"location":"generated/datatransformations/#AlgebraOfGraphics.histogram","page":"Data Transformations","title":"AlgebraOfGraphics.histogram","text":"histogram(; bins=automatic, weights=automatic, normalization=:none)\n\nCompute a histogram. bins can be an Int to create that number of equal-width bins over the range of values. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting normalization. Possible values are:\n\n:pdf: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.\n:density: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1.\n:probability: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.\n:none: Do not normalize.\n\nWeighted data is supported via the keyword weights.\n\nnote: Note\nNormalizations are computed withing groups. For example, in the case of normalization=:pdf, sum of weights within each group will be equal to 1.\n\n\n\n\n\n","category":"function"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"using AlgebraOfGraphics, CairoMakie\nset_aog_theme!()\n\ndf = (x=randn(1000), y=randn(1000), z=rand([\"a\", \"b\", \"c\"], 1000))\nspecs = data(df) * mapping(:x, layout=:z) * histogram(bins=range(-2, 2, length=15))\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"specs = data(df) * mapping(:x, dodge=:z, color=:z) * histogram(bins=range(-2, 2, length=15))\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"specs = data(df) * mapping(:x, stack=:z, color=:z) * histogram(bins=range(-2, 2, length=15))\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"data(df) * mapping(:x, :y, layout=:z) * histogram(bins=15) |> draw","category":"page"},{"location":"generated/datatransformations/#Density","page":"Data Transformations","title":"Density","text":"","category":"section"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"AlgebraOfGraphics.density","category":"page"},{"location":"generated/datatransformations/#AlgebraOfGraphics.density","page":"Data Transformations","title":"AlgebraOfGraphics.density","text":"density(; datalimits, npoints, kernel, bandwidth)\n\nFit a kernel density estimation of data. Here, datalimits specifies the range for which the density should be calculated, npoints is the number of points used by Makie to draw the line and kernel and bandwidth are forwarded to KernelDensity.kde.\n\n\n\n\n\n","category":"function"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"df = (x=randn(5000), y=randn(5000), z=rand([\"a\", \"b\", \"c\", \"d\"], 5000))\ndatalimits = ((-2.5, 2.5),)\nxz = data(df) * mapping(:x, layout=:z) * AlgebraOfGraphics.density(; datalimits)\naxis = (; ylabel=\"\")\ndraw(xz; axis)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"data(df) * mapping(:x, :y, layout=:z) * AlgebraOfGraphics.density(npoints=50) |> draw","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"specs = data(df) * mapping(:x, :y, layout=:z) *\n    AlgebraOfGraphics.density(npoints=50) * visual(Surface)\n\ndraw(specs, axis=(type=Axis3, zticks=0:0.1:0.2, limits=(nothing, nothing, (0, 0.2))))","category":"page"},{"location":"generated/datatransformations/#Frequency","page":"Data Transformations","title":"Frequency","text":"","category":"section"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"frequency","category":"page"},{"location":"generated/datatransformations/#AlgebraOfGraphics.frequency","page":"Data Transformations","title":"AlgebraOfGraphics.frequency","text":"frequency()\n\nCompute a frequency table of the arguments.\n\n\n\n\n\n","category":"function"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"df = (x=rand([\"a\", \"b\", \"c\"], 100), y=rand([\"a\", \"b\", \"c\"], 100), z=rand([\"a\", \"b\", \"c\"], 100))\nspecs = data(df) * mapping(:x, layout=:z) * frequency()\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"specs = data(df) * mapping(:x, layout=:z, color=:y, stack=:y) * frequency()\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"specs = data(df) * mapping(:x, :y, layout=:z) * frequency()\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/#Expectation","page":"Data Transformations","title":"Expectation","text":"","category":"section"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"expectation","category":"page"},{"location":"generated/datatransformations/#AlgebraOfGraphics.expectation","page":"Data Transformations","title":"AlgebraOfGraphics.expectation","text":"expectation(args...)\n\nCompute the expected value of the last argument conditioned on the preceding ones.\n\n\n\n\n\n","category":"function"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"df = (x=rand([\"a\", \"b\", \"c\"], 100), y=rand([\"a\", \"b\", \"c\"], 100), z=rand(100), c=rand([\"a\", \"b\", \"c\"], 100))\nspecs = data(df) * mapping(:x, :z, layout=:c) * expectation()\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"specs = data(df) * mapping(:x, :z, layout=:c, color=:y, dodge=:y) * expectation()\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"specs = data(df) * mapping(:x, :y, :z, layout=:c) * expectation()\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/#Linear","page":"Data Transformations","title":"Linear","text":"","category":"section"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"linear","category":"page"},{"location":"generated/datatransformations/#AlgebraOfGraphics.linear","page":"Data Transformations","title":"AlgebraOfGraphics.linear","text":"linear(; interval)\n\nCompute a linear fit of y ~ 1 + x. An optional named mapping weights determines the weights. Use interval to specify what type of interval the shaded band should represent. Valid values of interval are :confidence delimiting the uncertainty of the predicted relationship, and :prediction delimiting estimated bounds for new data points.\n\n\n\n\n\n","category":"function"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"x = 1:0.05:10\na = rand(1:7, length(x))\ny = 1.2 .* x .+ a .+ 0.5 .* randn.()\ndf = (; x, y, a)\nspecs = data(df) * mapping(:x, :y, color=:a => nonnumeric) * (linear() + visual(Scatter))\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/#Smoothing","page":"Data Transformations","title":"Smoothing","text":"","category":"section"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"smooth","category":"page"},{"location":"generated/datatransformations/#AlgebraOfGraphics.smooth","page":"Data Transformations","title":"AlgebraOfGraphics.smooth","text":"smooth(span=0.75, degree=2)\n\nFit a loess model. span is the degree of smoothing, typically in [0,1]. Smaller values result in smaller local context in fitting. degree is the polynomial degree used in the loess model.\n\n\n\n\n\n","category":"function"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"x = 1:0.05:10\na = rand(1:7, length(x))\ny = sin.(x) .+ a .+ 0.1 .* randn.()\ndf = (; x, y, a)\nspecs = data(df) * mapping(:x, :y, color=:a => nonnumeric) * (smooth() + visual(Scatter))\ndraw(specs)","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"","category":"page"},{"location":"generated/datatransformations/","page":"Data Transformations","title":"Data Transformations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"philosophy/#Philosophy","page":"Philosophy","title":"Philosophy","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"AlgebraOfGraphics aims to be a declarative, question-driven language for data visualizations. This section describes its main guiding principles.","category":"page"},{"location":"philosophy/#From-question-to-plot","page":"Philosophy","title":"From question to plot","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"When analyzing a dataset, we often think in abstract, declarative terms. We have questions concerning our data, which can be answered by appropriate visualizations. For instance, we could ask whether a discrete variable :x affects the distribution of a continuous variable :y. We would then like to generate a visualization that answers this question.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"In imperative programming, this would be implemented via the following steps.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Pick the dataset.\nDivide the dataset into subgroups according to the values of :x.\nCompute the density of :y on each subgroup.\nChoose a plot attribute to distinguish subgroups, for instance color.\nSelect as many distinguishable colors as there are unique values of :x.\nPlot all the density curves on top of each other.\nCreate a legend, describing how unique values of :x are associated to colors.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"While the above procedure is certainly feasible, it can introduce a cognitive overhead, especially when more variables and attributes are involved.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"In a declarative framework, the user needs to express the question, and the library will take care of creating the visualization. Let us solve the above problem in a toy dataset.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"using AlgebraOfGraphics, CairoMakie\nusing AlgebraOfGraphics: density\nset_aog_theme!()\nN = 1000\nx = rand([\"Class 1\", \"Class 2\", \"Class 3\", \"Class 4\"], N)\ny = @. (x == \"Class 1\") * randn() + (x == \"Class 2\") - (x == \"Class 3\") + randn()\nz = @. (x == \"Class 2\") * randn() + (x == \"Class 2\") + (x == \"Class 3\") + y + randn()\ndf = (; x, y, z)","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"plt = data(df) # declare the dataset\nplt *= density() # declare the analysis\nplt *= mapping(:y) # declare the arguments of the analysis\nplt *= mapping(color = :x) # declare the grouping and the respective visual attribute\ndraw(plt) # draw the visualization and its legend","category":"page"},{"location":"philosophy/#No-mind-reading","page":"Philosophy","title":"No mind reading","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Plotting packages requires the user to specify a large amount of settings. The temptation is then to engineer a plotting library in such a way that it would guess what the user actually wanted. AlgebraOfGraphics follows a different approach, based on algebraic manipulations of plot descriptors.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"The key intuition is that a large fraction of the \"clutter\" in a plot specification comes from repeating the same information over and over. Different layers of the same plot will share some but not all information, and the user should be able to distinguish settings that are private to a layer from those that are shared across layers.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"We achieve this goal using the distributive properties of addition and multiplication. This is best explained by example. Let us assume that we wish to visually inspect whether a discrete variable :x affects the joint distribution of two continuous variables, :y and :z.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"We would like to have two layers, one with the raw data, the other with an analysis (kernel density estimation).","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Naturally, the axes should represent the same variables (:y and :z) for both layers. Only the density layer should be a contour plot, whereas only the scatter layer should have some transparency and be grouped (according to :x) in different subplots.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"plt = data(df) *\n    (\n        visual(Scatter, alpha = 0.3) * mapping(layout = :x) +\n        density() * visual(Contour, colormap = Reverse(:grays))\n    ) *\n    mapping(:y, :z)\ndraw(plt)","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"In this case, thanks to the distributive property, it is clear that the dataset and the positional arguments :y, :z are shared across layers, the transparency and the grouping are specific to the data layer, whereas the density analysis, the Contour visualization, and the choice of color map are specific to the analysis layer.","category":"page"},{"location":"philosophy/#User-defined-building-blocks","page":"Philosophy","title":"User-defined building blocks","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"It is common in data analysis tasks to \"pipe\" a sequence of operations. This became very popular in the data science field with the %>% operator in the R language, and it can allow users to seamlessly compose a sequence of tasks:","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"df %>%\n    filter(Weight < 3) %>%\n    group_by(Species) %>%\n    summarise(avg_height = mean(Height))","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Naturally, the alternative would be to create a statement per operation and to assign each intermediate result to its own variable.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"AlgebraOfGraphics is markedly in favor of the latter approach. It is recommended that commonly used building blocks are stored in variables with meaningful names. If we often make a scatter plot with some transparency, we can create a variable transparent_scatter = visual(Scatter, alpha = 0.5) and use it consistently. If some columns of our dataset are always analyzed together, with a similar set of transformations, we can store that information as variables = mapping(variable1 => f1 => label1, variable2 => f2 => label2).","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Working over one or more datasets, the user would then create a library of building blocks to be combined with each other with * and +. These two operators allow for a much larger number of possible combinations than just sequential composition, thus fully justifying the extra characters used to name intermediate entities.","category":"page"},{"location":"philosophy/#Opinionated-defaults","page":"Philosophy","title":"Opinionated defaults","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"While users should be able to customize every aspect of their plots, it is important to note that this customization can be very time-consuming, and many subtleties can escape the attention of the casual user:","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Is the color palette colorblind-friendly?\nWould the colors be distinguishable in black and white (when printed)?\nIs the color gradient perceptually uniform?\nAre the labels and the ticks legible for readers with low vision?\nAre the spacing and typographic hierarchies respected?","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"To remedy this, AlgebraOfGraphics aims to provide solid, opinionated default settings. In particular, it uses a conservative, colorblind-friendly palette and a perceptually uniform, universally readable color map. It follows IBM guidelines to differentiate titles and labels from tick labels via font weight, while using the same typeface at a readable size.","category":"page"},{"location":"philosophy/#Wide-format-support","page":"Philosophy","title":"Wide format support","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Finally, AlgebraOfGraphics aims to support many different data formats. Different problems require organizing the data in different formats, and AlgebraOfGraphics should support a wide range of options.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"This is achieved in three different ways. First, the Tables interface ensures integration with a large variety of data sources. Second, using the Wide data syntax, users can compare many different columns in the same visualization, without having to first reshape the dataset to a long format. Finally, tabular datasets are not a requirement: users may also work directly with Pre-grouped data, which are not organized as a table, but rather as a collection of (possibly multi-dimensional) arrays.","category":"page"},{"location":"layers/operations/#Algebraic-Operations","page":"Algebraic Operations","title":"Algebraic Operations","text":"","category":"section"},{"location":"layers/operations/#Multiplication-on-individual-layers","page":"Algebraic Operations","title":"Multiplication on individual layers","text":"","category":"section"},{"location":"layers/operations/","page":"Algebraic Operations","title":"Algebraic Operations","text":"Each layer is composed of data, mappings, and transformations. Datasets can be replaced, mappings can be merged, and transformations can be concatenated. These operations, taken together, define an associative operation on layers, which we call multiplication *.","category":"page"},{"location":"layers/operations/","page":"Algebraic Operations","title":"Algebraic Operations","text":"Multiplication is primarily useful to combine partially defined layers.","category":"page"},{"location":"layers/operations/#Addition","page":"Algebraic Operations","title":"Addition","text":"","category":"section"},{"location":"layers/operations/","page":"Algebraic Operations","title":"Algebraic Operations","text":"The operation + is used to superimpose separate layers. a + b has as many layers as la + lb, where la and lb are the number of layers in a and b respectively.","category":"page"},{"location":"layers/operations/#Multiplication-on-lists-of-layers","page":"Algebraic Operations","title":"Multiplication on lists of layers","text":"","category":"section"},{"location":"layers/operations/","page":"Algebraic Operations","title":"Algebraic Operations","text":"Multiplication naturally extends to lists of layers. Given two Layers objects a and b, containing la and lb layers respectively, the product a * b contains la * lb layers—all possible pair-wise products.","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/gallery.jl\"","category":"page"},{"location":"generated/gallery/#Example-gallery","page":"Example gallery","title":"Example gallery","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"Semi-curated collection of examples.","category":"page"},{"location":"generated/gallery/#Lines-and-markers","page":"Example gallery","title":"Lines and markers","text":"","category":"section"},{"location":"generated/gallery/#A-simple-scatter-plot","page":"Example gallery","title":"A simple scatter plot","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"using AlgebraOfGraphics, CairoMakie\nset_aog_theme!()\n\ndf = (x=rand(100), y=rand(100))\nxy = data(df) * mapping(:x, :y)\ndraw(xy)","category":"page"},{"location":"generated/gallery/#A-simple-lines-plot","page":"Example gallery","title":"A simple lines plot","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = range(-π, π, length=100)\ny = sin.(x)\ndf = (; x, y)\nxy = data(df) * mapping(:x, :y)\nlayer = visual(Lines)\ndraw(layer * xy)","category":"page"},{"location":"generated/gallery/#Lines-and-scatter-combined-plot","page":"Example gallery","title":"Lines and scatter combined plot","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = range(-π, π, length=100)\ny = sin.(x)\ndf = (; x, y)\nxy = data(df) * mapping(:x, :y)\nlayers = visual(Scatter) + visual(Lines)\ndraw(layers * xy)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = range(-π, π, length=100)\ny = sin.(x)\ndf1 = (; x, y)\ndf2 = (x=rand(10), y=rand(10))\nlayers = data(df1) * visual(Lines) + data(df2) * visual(Scatter)\ndraw(layers * mapping(:x, :y))","category":"page"},{"location":"generated/gallery/#Linear-regression-on-a-scatter-plot","page":"Example gallery","title":"Linear regression on a scatter plot","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand(100), y=rand(100), z=rand(100))\nxy = data(df) * mapping(:x, :y)\nlayers = linear() + visual(Scatter) * mapping(color=:z)\ndraw(layers * xy)","category":"page"},{"location":"generated/gallery/#Faceting","page":"Example gallery","title":"Faceting","text":"","category":"section"},{"location":"generated/gallery/#Facet-grid","page":"Example gallery","title":"Facet grid","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand(100), y=rand(100), i=rand([\"a\", \"b\", \"c\"], 100), j=rand([\"d\", \"e\", \"f\"], 100))\nplt = data(df) * mapping(:x, :y, col=:i, row=:j)\ndraw(plt)","category":"page"},{"location":"generated/gallery/#Facet-wrap","page":"Example gallery","title":"Facet wrap","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand(100), y=rand(100), l=rand([\"a\", \"b\", \"c\", \"d\", \"e\"], 100))\nplt = data(df) * mapping(:x, :y, layout=:l)\ndraw(plt)","category":"page"},{"location":"generated/gallery/#Embedding-facets","page":"Example gallery","title":"Embedding facets","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"All AlgebraOfGraphics plots can be inserted in any figure position, where the rest of the figure is managed by vanilla Makie. For example","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"resolution = (800, 400)\nfig = Figure(; resolution)\nax = Axis(fig[1, 1], title=\"Some plot\")\n\ndf = (x=rand(100), y=rand(100), i=rand([\"a\", \"b\", \"c\"], 100), j=rand([\"d\", \"e\", \"f\"], 100))\nplt = data(df) * mapping(:x, :y, col=:i, row=:j)\n\nsubfig = fig[1, 2:3]\nag = draw!(subfig, plt)\nfor ae in ag\n    Axis(ae).xticklabelrotation[] = π/2\nend\nfig","category":"page"},{"location":"generated/gallery/#Adding-traces-to-only-some-subplots","page":"Example gallery","title":"Adding traces to only some subplots","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df1 = (x=rand(100), y=rand(100), i=rand([\"a\", \"b\", \"c\"], 100), j=rand([\"d\", \"e\", \"f\"], 100))\ndf2 = (x=[0, 1], y=[0.5, 0.5], i=fill(\"a\", 2), j=fill(\"e\", 2))\nlayers = data(df1) * visual(Scatter) + data(df2) * visual(Lines)\ndraw(layers * mapping(:x, :y, col=:i, row=:j))","category":"page"},{"location":"generated/gallery/#Statistical-analyses","page":"Example gallery","title":"Statistical analyses","text":"","category":"section"},{"location":"generated/gallery/#Density-plot","page":"Example gallery","title":"Density plot","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"using AlgebraOfGraphics: density\ndf = (x=randn(1000), c=rand([\"a\", \"b\"], 1000))\nplt = data(df) * mapping(:x, color=:c) * density(bandwidth=0.5)\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=randn(1000), c=rand([\"a\", \"b\"], 1000))\nplt = data(df) * mapping(:x, color=:c) * density(bandwidth=0.5) * visual(orientation=:vertical)\n\"Not yet supported\" # hide","category":"page"},{"location":"generated/gallery/#Discrete-scales","page":"Example gallery","title":"Discrete scales","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"By default categorical ticks, as well as names from legend entries, are taken from the value of the variable converted to a string. Scales can be equipped with labels to overwrite that","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand([\"a\", \"b\", \"c\"], 100), y=rand(100))\nplt = data(df) * mapping(:x, :y) * visual(BoxPlot)\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand([\"a\", \"b\", \"c\"], 100), y=rand(100))\nplt = data(df) *\n    mapping(\n        :x => renamer(\"a\" => \"label1\", \"b\" => \"label2\", \"c\" => \"label3\"),\n        :y\n    ) * visual(BoxPlot)\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"The order can also be changed by tweaking the scale","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"plt = data(df) *\n    mapping(\n        :x => renamer(\"b\" => \"label b\", \"a\" => \"label a\", \"c\" => \"label c\"),\n        :y\n    ) * visual(BoxPlot)\ndraw(plt)","category":"page"},{"location":"generated/gallery/#Continuous-scales","page":"Example gallery","title":"Continuous scales","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = 1:100\ny = @. sqrt(x) + 20x + 100\ndf = (; x, y)\nplt = data(df) *\n    mapping(\n        :x,\n        :y => log => \"√x + 20x + 100 (log scale)\",\n    ) * visual(Lines)\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = 1:100\ny = @. sqrt(x) + 20x + 100\ndf = (; x, y)\nplt = data(df) *\n    mapping(\n        :x,\n        :y => \"√x + 20x + 100 (log scale)\",\n    ) * visual(Lines)\ndraw(plt, axis=(yscale=log,))","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = 0:100\ny = @. 0.01 + x/1000\ndf = (; x, y)\nplt = data(df) *\n    mapping(\n        :x,\n        :y => \"y\",\n    ) * visual(Lines)\ndraw(plt, axis=(yscale=log,))","category":"page"},{"location":"generated/gallery/#Custom-scales","page":"Example gallery","title":"Custom scales","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"Sometimes, there is no default palettes for a specific attribute. In that case, the user can pass their own. TODO: allow legend to use custom attribute of plot, such as the arrowhead or the arrowcolor and pass correct legend symbol.","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"using Colors\nx=repeat(1:20, inner=20)\ny=repeat(1:20, outer=20)\nu=cos.(x)\nv=sin.(y)\nc=rand(Bool, length(x))\nd=rand(Bool, length(x))\ndf = (; x, y, u, v, c, d)\ncolors = [colorant\"#E24A33\", colorant\"#348ABD\"]\nheads = ['▲', '●']\nplt = data(df) *\n    mapping(:x, :y, :u, :v) *\n    mapping(arrowhead=:c => nonnumeric) *\n    mapping(arrowcolor=:d => nonnumeric) *\n    visual(Arrows, arrowsize=10, lengthscale=0.3)\ndraw(plt; palettes=(arrowcolor=colors, arrowhead=heads))","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"To associate specific attribute values to specific data values, use pairs. Missing keys will cycle over values that are not pairs.","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = rand(100)\ny = rand(100)\nz = rand([\"a\", \"b\", \"c\", \"d\"], 100)\ndf = (; x, y, z)\nplt = data(df) * mapping(:x, :y, color=:z)\ncolors = [\"a\" => colorant\"#E24A33\", \"c\" => colorant\"#348ABD\", colorant\"#988ED5\", colorant\"#777777\"]\ndraw(plt; palettes=(color=colors,))","category":"page"},{"location":"generated/gallery/#Axis-and-figure-keywords","page":"Example gallery","title":"Axis and figure keywords","text":"","category":"section"},{"location":"generated/gallery/#Axis-tweaking","page":"Example gallery","title":"Axis tweaking","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"To tweak one or more axes, simply use the axis keyword when plotting. For example","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand(100), y=rand(100), z=rand(100))\nlayers = linear() + mapping(color=:z)\nplt = data(df) * layers * mapping(:x, :y)\ndraw(plt, axis=(aspect=1,))","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"draw(plt, axis=(aspect=1, xticks=0:0.1:1, yticks=0:0.1:1, ylabel=\"custom label\"))","category":"page"},{"location":"generated/gallery/#Figure-tweaking","page":"Example gallery","title":"Figure tweaking","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand(100), y=rand(100), z=rand(100), c=rand([\"a\", \"b\"], 100))\nxyc = data(df) * mapping(:x, :y, layout=:c)\nlayers = linear() + mapping(color=:z)\nplt = xyc * layers\ndraw(plt, axis=(aspect=1,), figure=(resolution=(800, 400),))","category":"page"},{"location":"generated/gallery/#Wide-data","page":"Example gallery","title":"Wide data","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (a=randn(100), b=randn(100), c=randn(100))\nlabels = [\"Trace 1\", \"Trace 2\", \"Trace 3\"]\nplt = data(df) *\n    density() *\n    mapping([:a, :b, :c] .=> \"some label\") *\n    mapping(color=dims(1) => renamer(labels))\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (a=rand(100), b=rand(100), c=rand(100), d=rand(100))\nlabels = [\"Trace 1\", \"Trace 2\", \"Trace 3\"]\nlayers = linear() + visual(Scatter)\nplt = data(df) * layers * mapping(1, 2:4 .=> \"value\", color=dims(1) => renamer(labels))\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"The wide format is combined with broadcast semantics.","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (sepal_length=rand(100), sepal_width=rand(100), petal_length=rand(100), petal_width=rand(100))\nxvars = [\"sepal_length\", \"sepal_width\"]\nyvars = [\"petal_length\" \"petal_width\"]\nlayers = linear() + visual(Scatter)\nplt = data(df) * layers * mapping(xvars, yvars, col=dims(1), row=dims(2))\ndraw(plt)","category":"page"},{"location":"generated/gallery/#Time-series","page":"Example gallery","title":"Time series","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"using Dates\n\nx = today() - Year(1) : Day(1) : today()\ny = cumsum(randn(length(x)))\nz = cumsum(randn(length(x)))\ndf = (; x, y, z)\nlabels = [\"series 1\", \"series 2\", \"series 3\", \"series 4\", \"series 5\"]\nplt = data(df) *\n    mapping(:x, [:y, :z] .=> \"value\", color=dims(1) => renamer(labels) => \"series \") *\n    visual(Lines)\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = now() - Hour(6) : Minute(1) : now()\ny = cumsum(randn(length(x)))\nz = cumsum(randn(length(x)))\ndf = (; x, y, z)\nplt = data(df) *\n    mapping(:x, [:y, :z] .=> \"value\", color=dims(1) => renamer(labels) =>\"series \") *\n    visual(Lines)\ndraw(plt)","category":"page"},{"location":"generated/gallery/#Geometries","page":"Example gallery","title":"Geometries","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"using GeometryBasics\n\ngeometry = [Rect(Vec(i, j), Vec(1, 1)) for i in 0:7 for j in 0:7]\ngroup = [isodd(i + j) ? \"light square\" : \"dark square\" for i in 0:7 for j in 0:7]\ndf = (; geometry, group)\n\nplt = data(df) * visual(Poly) * mapping(:geometry, color = :group)\ndraw(plt; axis=(aspect=1,))","category":"page"},{"location":"generated/gallery/#Geographic-data","page":"Example gallery","title":"Geographic data","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"Antarctic coastline. Data from the SCAR Antarctic Digital Database[1].","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"[1]: Gerrish, L., Fretwell, P., & Cooper, P. (2021). Medium resolution vector polygons of the Antarctic coastline (7.4) [Data set]. UK Polar Data Centre, Natural Environment Research Council, UK Research & Innovation. https://doi.org/10.5285/747e63e-9d93-49c2-bafc-cf3d3f8e5afa","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"# Download, extract, and load shapefile\nusing Shapefile, ZipFile\nusing Downloads: download\nt = mktempdir() do dir\n    url = \"https://data.bas.ac.uk/download/7be3ab29-7caa-46b8-a355-2e3233796e86\"\n    r = ZipFile.Reader(seekstart(download(url, IOBuffer())))\n    for f in r.files\n        open(joinpath(dir, f.name), write = true) do io\n            write(io, read(f, String));\n        end\n    end\n    Shapefile.Table(joinpath(dir, \"add_coastline_medium_res_polygon_v7_4.shp\"))\nend\n\n# Draw map\nplt = geodata(t) * mapping(:geometry, color = :surface) * visual(Poly)\ndraw(plt; axis=(aspect=1,))","category":"page"},{"location":"generated/gallery/#New-columns-on-the-fly","page":"Example gallery","title":"New columns on the fly","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"Use a Tuple to pass combine several columns into a unique operation.","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"df = (x=rand(100), y=rand(100), z=rand(100), c=rand([\"a\", \"b\"], 100))\nlayers = linear() + mapping(color=:z)\nplt = data(df) * layers * mapping(:x, (:x, :y, :z) => (+) => \"x + y + z\", layout=:c)\ndraw(plt)","category":"page"},{"location":"generated/gallery/#Pre-grouped-data","page":"Example gallery","title":"Pre-grouped data","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"x = [rand(10) for i in 1:3]\ny = [rand(10) for i in 1:3]\nz = [rand(10) for i in 1:3]\nc = [\"a\", \"b\", \"c\"]\n\nm = mapping(x, y, color=c => (t -> \"Type \" * t ) => \"Category\")\ndraw(m)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"m = mapping(x, (y, z) => (+) => \"sum\", color=c => (t -> \"Type \" * t ) => \"Category\")\ndraw(m)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"m = mapping(x, [y z], color=dims(1) => renamer([\"a\", \"b\", \"c\"]))\ndraw(m)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"m = mapping(x, [y z], color=[\"1\" \"2\"])\nlayers = visual(Scatter) + linear()\ndraw(m * layers)","category":"page"},{"location":"generated/gallery/#Legend-merging","page":"Example gallery","title":"Legend merging","text":"","category":"section"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"N = 40\n\nx = [1:N; 1:N]\ny = [cumsum(randn(N)); cumsum(randn(N))]\ngrp = [fill(\"a\", N); fill(\"b\", N)]\n\ndf = (; x, y, grp)\n\nlayers = visual(Lines) + visual(Scatter) * mapping(marker = :grp)\nplt = data(df) * layers * mapping(:x, :y, color = :grp)\n\ndraw(plt)","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"","category":"page"},{"location":"generated/gallery/","page":"Example gallery","title":"Example gallery","text":"This page was generated using Literate.jl.","category":"page"},{"location":"layers/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"layers/introduction/","page":"Introduction","title":"Introduction","text":"Layers are the key building block of AlgebraOfGraphicss.","category":"page"},{"location":"layers/introduction/","page":"Introduction","title":"Introduction","text":"Each layer is composed of the following fields.","category":"page"},{"location":"layers/introduction/","page":"Introduction","title":"Introduction","text":"Data.\nMappings.\nTransformations:\nVisual Transformations,\nData Transformations.","category":"page"},{"location":"layers/introduction/","page":"Introduction","title":"Introduction","text":"Layers can be combined with Algebraic Operations.","category":"page"},{"location":"layers/introduction/","page":"Introduction","title":"Introduction","text":"Finally, Drawing Layers is the last step of the pipeline.","category":"page"},{"location":"layers/data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"layers/data/","page":"Data","title":"Data","text":"The data field of a layer contains the dataset that will be used to populate the plot. There are no type restrictions on this dataset, as long as it respects the Tables interface. In particular, any one of these formats should work out of the box.","category":"page"},{"location":"layers/data/","page":"Data","title":"Data","text":"The data helper function creates an under-defined layer, where only the data field is populated..","category":"page"},{"location":"layers/data/","page":"Data","title":"Data","text":"using AlgebraOfGraphics\ndf = (a = rand(10), b = rand(10))\ndata(df)","category":"page"},{"location":"generated/entries/","page":"Entries","title":"Entries","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/entries.jl\"","category":"page"},{"location":"generated/entries/#Entries","page":"Entries","title":"Entries","text":"","category":"section"},{"location":"generated/entries/","page":"Entries","title":"Entries","text":"The key ingredient for data representations are AxisEntries.","category":"page"},{"location":"generated/entries/#The-AxisEntries-type","page":"Entries","title":"The AxisEntries type","text":"","category":"section"},{"location":"generated/entries/","page":"Entries","title":"Entries","text":"An AxisEntries object is made of four components:","category":"page"},{"location":"generated/entries/","page":"Entries","title":"Entries","text":"axis,\nentries,\nscales,\nlabels.","category":"page"},{"location":"generated/entries/","page":"Entries","title":"Entries","text":"using AlgebraOfGraphics, CairoMakie\nusing AlgebraOfGraphics: CategoricalScale, ContinuousScale\nresolution = (600, 600)\nfig = Figure(; resolution)\nN = 11\nrg = range(1, 2, length=N)\nae = AxisEntries(\n    Axis(fig[1, 1]),\n    [\n        Entry(\n            plottype=Scatter,\n            positional=(rg, cosh.(rg)),\n            named=(color=1:N, marker=fill(\"b\", N));\n            attributes=Dict(:markersize => 15)\n        ),\n        Entry(\n            plottype=Scatter,\n            positional=(rg, sinh.(rg)),\n            named=(color=1:N, marker=fill(\"c\", N));\n            attributes=Dict(:markersize => 15)\n        ),\n    ],\n    Dict(\n        1 => ContinuousScale(identity, (0, 4)),\n        2 => ContinuousScale(identity, (0, 4)),\n        :color => ContinuousScale(identity, (1, N)),\n        :marker => CategoricalScale([\"a\", \"b\", \"c\"], [:circle, :utriangle, :dtriangle]),\n    ), # scales\n    Dict(\n        1 => \"x\",\n        2 => \"y\",\n        :color => \"identity\",\n        :marker => \"function\"\n    ), # labels\n)\nplot!(ae)\nfig","category":"page"},{"location":"generated/entries/","page":"Entries","title":"Entries","text":"","category":"page"},{"location":"generated/entries/","page":"Entries","title":"Entries","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/visualtransformations.jl\"","category":"page"},{"location":"generated/visualtransformations/#Visual-Transformations","page":"Visual Transformations","title":"Visual Transformations","text":"","category":"section"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"The function visual can be used to give data-independent visual information about the plot (plotting function or attributes).","category":"page"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"using AlgebraOfGraphics, CairoMakie, PalmerPenguins, DataFrames\nset_aog_theme!()\n\npenguins = dropmissing(DataFrame(PalmerPenguins.load()))\n\ndata(penguins) * visual(Violin) *\n    mapping(:species, :bill_depth_mm, color=:sex, dodge=:sex) |> draw","category":"page"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"plt = data(penguins) * visual(Violin)\nplt *= mapping(:species, :bill_depth_mm, color=:sex, side=:sex, dodge=:island)\ndraw(plt, axis=(limits=((0.5, 3.5), nothing),))","category":"page"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"data(penguins) * visual(BoxPlot, show_notch=true) *\n    mapping(:species, :bill_depth_mm, color=:sex, dodge=:sex) |> draw","category":"page"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"data(penguins) *\n    mapping(:bill_length_mm, :bill_depth_mm, col=:sex) *\n    visual(QQPlot, qqline=:fit) |> draw","category":"page"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"","category":"page"},{"location":"generated/visualtransformations/","page":"Visual Transformations","title":"Visual Transformations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/penguins.jl\"","category":"page"},{"location":"generated/penguins/#Tutorial","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"This is a gentle and lighthearted tutorial on how to use tools from AlgebraOfGraphics, using as example dataset a collection of measurements on penguins[1]. See the Palmer penguins website for more information.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"[1]: Gorman KB, Williams TD, Fraser WR (2014) Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3): e90081. DOI","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"To follow along this tutorial, you will need to install a few packages. All the required packages can be installed with the following command.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"julia> import Pkg; Pkg.add([\"AlgebraOfGraphics\", \"CairoMakie\", \"DataFrames\", \"LIBSVM\", \"PalmerPenguins\"])","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"After the above command completes, we are ready to go.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"using PalmerPenguins, DataFrames\n\npenguins = dropmissing(DataFrame(PalmerPenguins.load()))\nfirst(penguins, 6)","category":"page"},{"location":"generated/penguins/#Frequency-plots","page":"Tutorial 🐧","title":"Frequency plots","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Let us start by getting a rough idea of how the data is distributed.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"note: Note\nDue to julia's compilation model, the first plot may take a while to appear.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"using AlgebraOfGraphics, CairoMakie\nset_aog_theme!()\n\naxis = (width = 225, height = 225)\npenguin_frequency = data(penguins) * frequency() * mapping(:species)\n\ndraw(penguin_frequency; axis)","category":"page"},{"location":"generated/penguins/#Small-intermezzo:-saving-the-plot","page":"Tutorial 🐧","title":"Small intermezzo: saving the plot","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"If you are working in an interactive enviroment with inline plotting support, such VSCode or Pluto.jl, the above should have displayed a bar plot. If you are working directly in the console, you can simply save the plot and inspect it in the file explorer.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"fg = draw(penguin_frequency; axis)\nsave(\"figure.png\", fg, px_per_unit = 3) # save high-resolution png","category":"page"},{"location":"generated/penguins/#Styling-by-categorical-variables","page":"Tutorial 🐧","title":"Styling by categorical variables","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Next, let us see whether the distribution is the same across islands.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_frequency * mapping(color = :island)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Ups! The bars are in the same spot and are hiding each other. We need to specify how we want to fix this. Bars can either dodge each other, or be stacked on top of each other.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_frequency * mapping(color = :island, dodge = :island)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"This is our first finding. Adelie is the only species of penguins that can be found on all three islands. To be able to see both which species is more numerous and how different species are distributed across islands in a unique plot, we could have used stack.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_frequency * mapping(color = :island, stack = :island)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/#Correlating-two-variables","page":"Tutorial 🐧","title":"Correlating two variables","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Now that we have understood the distribution of these three penguin species, we can start analyzing their features.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"penguin_bill = data(penguins) * mapping(:bill_length_mm, :bill_depth_mm)\ndraw(penguin_bill; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"We would actually prefer to visualize these measures in centimeters, and to have cleaner axes labels. As we want this setting to be preserved in all of our bill visualizations, let us save it in the variable penguin_bill, to be reused in subsequent plots.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"penguin_bill = data(penguins) * mapping(\n    :bill_length_mm => (t -> t / 10) => \"bill length (cm)\",\n    :bill_depth_mm => (t -> t / 10) => \"bill depth (cm)\",\n)\ndraw(penguin_bill; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Much better! Note the parentheses around the function t -> t / 10. They are necessary to specify that the function maps t to t / 10, and not to t / 10 => \"bill length (cm)\".","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"There does not seem to be a strong correlation between the two dimensions, which is odd. Maybe dividing the data by species will help.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_bill * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Ha! Within each species, penguins with a longer bill also have a deeper bill. We can confirm that with a linear regression","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_bill * linear() * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"This unfortunately no longer shows our data! We can use + to plot both things on top of each other:","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_bill * linear() * mapping(color = :species) + penguin_bill * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Note that the above expression seems a bit redundant, as we wrote the same thing twice. We can \"factor it out\" as follows","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_bill * (linear() + mapping()) * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"where mapping() is a neutral multiplicative element. Of course, the above could be refactored as","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"layers = linear() + mapping()\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"We could actually take advantage of the spare mapping() and use it to pass some extra info to the scatter, while still using all the species members to compute the linear fit.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"layers = linear() + mapping(marker = :sex)\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"This plot is getting a little bit crowded. We could instead show female and male penguins in separate subplots.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"layers = linear() + mapping(col = :sex)\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"See how both plots show the same fit, because the sex mapping is not applied to linear(). The following on the other hand produces a separate fit for males and females:","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"layers = linear() + mapping()\nplt = penguin_bill * layers * mapping(color = :species, col = :sex)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/#Smooth-density-plots","page":"Tutorial 🐧","title":"Smooth density plots","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"An alternative approach to understanding how two variables interact is to consider their joint probability density distribution (pdf).","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"using AlgebraOfGraphics: density\nplt = penguin_bill * density(npoints=50) * mapping(col = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"The default colormap is multi-hue, but it is possible to pass single-hue colormaps as well:","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt *= visual(colormap = :grayC)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"A Heatmap (the default visualization for a 2D density) is a bit unfortunate if we want to mark species by color. In that case, one can use visual to change the default visualization and, optionally, fine tune some arguments. In this case, a Wireframe with thin lines looks quite nice. (Note that, for the time being, we must specify explicitly that we require a 3D axis.)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"axis = (type = Axis3, width = 300, height = 300)\nlayer = density() * visual(Wireframe, linewidth=0.05)\nplt = penguin_bill * layer * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Of course, a more traditional approach would be to use a Contour plot instead:","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"axis = (width = 225, height = 225)\nlayer = density() * visual(Contour)\nplt = penguin_bill * layer * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"The data and the linear fit can also be added back to the plot:","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"layers = density() * visual(Contour) + linear() + mapping()\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"In the case of many layers (contour, density and scatter) it is important to think about balance. In the above plot, the markers are quite heavy and can obscure the linear fit and the contour lines. We can lighten the markers using alpha transparency.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"layers = density() * visual(Contour) + linear() + visual(alpha = 0.5)\nplt = penguin_bill * layers * mapping(color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/#Correlating-three-variables","page":"Tutorial 🐧","title":"Correlating three variables","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"We are now mostly up to speed with bill size, but we have not considered how it relates to other penguin features, such as their weight. For that, a possible approach is to use a continuous color on a gradient to denote weight and different marker shapes to denote species. Here we use group to split the data for the linear regression without adding any additional style.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"body_mass = :body_mass_g => (t -> t / 1000) => \"body mass (kg)\"\nlayers = linear() * mapping(group = :species) + mapping(color = body_mass, marker = :species)\nplt = penguin_bill * layers\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Naturally, within each species, heavier penguins have bigger bills, but perhaps counter-intuitively the species with the shallowest bills features the heaviest penguins. We could also try and see the interplay of these three variables in a 3D plot.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"axis = (type = Axis3, width = 300, height = 300)\nplt = penguin_bill * mapping(body_mass, color = :species)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"plt = penguin_bill * mapping(body_mass, color = :species, layout = :sex)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Note that static 3D plot can be misleading, as they only show one projection of 3D data. They are mostly useful when shown interactively.","category":"page"},{"location":"generated/penguins/#Machine-Learning","page":"Tutorial 🐧","title":"Machine Learning","text":"","category":"section"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Finally, let us use Machine Learning techniques to build an automated penguin classifier!","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"We would like to investigate whether it is possible to predict the species of a penguin based on its bill size. To do so, we will use a standard classifier technique called Support-Vector Machine.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"The strategy is quite simple. We split the data into training and testing subdatasets. We then train our classifier on the training dataset and use it to make predictions on the whole data. We then add the new columns obtained this way to the dataset and visually inspect how well the classifier performed in both training and testing.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"using LIBSVM, Random\n\n# use approximately 80% of penguins for training\nRandom.seed!(1234) # for reproducibility\nN = nrow(penguins)\ntrain = fill(false, N)\nperm = randperm(N)\ntrain_idxs = perm[1:floor(Int, 0.8N)]\ntrain[train_idxs] .= true\nnothing # hide\n\n# fit model on training data and make predictions on the whole dataset\nX = hcat(penguins.bill_length_mm, penguins.bill_depth_mm)\ny = penguins.species\nmodel = SVC() # Support-Vector Machine Classifier\nfit!(model, X[train, :], y[train])\nŷ = predict(model, X)\n\n# incorporate relevant information in the dataset\npenguins.train = train\npenguins.predicted_species = ŷ\nnothing #hide","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Now, we have all the columns we need to evaluate how well our classifier performed.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"axis = (width = 225, height = 225)\ndataset =:train => renamer(true => \"training\", false => \"testing\") => \"Dataset\"\naccuracy = (:species, :predicted_species) => isequal => \"accuracy\"\nplt = data(penguins) *\n    expectation() *\n    mapping(:species, accuracy) *\n    mapping(col = dataset)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"That is a bit hard to read, as all values are very close to 1. Let us visualize the error rate instead.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"error_rate = (:species, :predicted_species) => !isequal => \"error rate\"\nplt = data(penguins) *\n    expectation() *\n    mapping(:species, error_rate) *\n    mapping(col = dataset)\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"So, mostly our classifier is doing quite well, but there are some mistakes, especially among Chinstrap penguins. Using at the same time the species and predicted_species mappings on different attributes, we can see which penguins are problematic.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"prediction = :predicted_species => \"predicted species\"\ndatalayer = mapping(color = prediction, row = :species, col = dataset)\nplt = penguin_bill * datalayer\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"Um, some of the penguins are indeed being misclassified... Let us try to understand why by adding an extra layer, which describes the density of the distributions of the three species.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"pdflayer = density() * visual(Contour, colormap=Reverse(:grays)) * mapping(group = :species)\nlayers = pdflayer + datalayer\nplt = penguin_bill * layers\ndraw(plt; axis)","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"We can conclude that the classifier is doing a reasonable job: it is mostly making mistakes on outlier penguins.","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"","category":"page"},{"location":"generated/penguins/","page":"Tutorial 🐧","title":"Tutorial 🐧","text":"This page was generated using Literate.jl.","category":"page"},{"location":"layers/mappings/#Mappings","page":"Mappings","title":"Mappings","text":"","category":"section"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"Mappings determine how the date is translated into a plot. Positional mappings correspond to the x, y or z axes of the plot, whereas the keyword arguments correspond to plot attributes that can vary continuously or discretely, such as color or markersize.","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"Mapping variables  are split according to the categorical attributes in it, and then converted to plot attributes using a default palette.","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"using AlgebraOfGraphics\nmapping(:weight_mm => \"weight (mm)\", :height_mm => \"height (mm)\", marker = :gender)","category":"page"},{"location":"layers/mappings/#Pair-syntax","page":"Mappings","title":"Pair syntax","text":"","category":"section"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"A convenience pair-based syntax can be used to transform variables on-the-fly and rename the respective column.","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"Let us assume the table df contains a column called bill_length_mm. We can apply an element-wise transformation and rename the column on the fly as follows.","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"data(df) * mapping(:bill_length_mm => (t -> t / 10) => \"bill length (cm)\")","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"A possible alternative, if df is a DataFrame, would be to store a renamed, modified column directly in df, which can be achieved in the following way: ","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"df.var\"bill length (cm)\" = map(t -> t / 10, df.bill_length_mm)\ndata(df) * mapping(\"bill length (cm)\") # strings are also accepted for column names","category":"page"},{"location":"layers/mappings/#Row-by-row-versus-whole-column-operations","page":"Mappings","title":"Row-by-row versus whole-column operations","text":"","category":"section"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"The pair syntax acts row by row, unlike, e.g., DataFrames.transform. This has several advantages.","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"Simpler for the user in most cases.\nLess error prone especially\nwith grouped data (should a column operation apply to each group or the whole dataset?)\nwhen several datasets are used","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"Naturally, this also incurs some downsides, as whole-column operations, such as z-score standardization, are not supported: they should be done by adding a new column to the underlying dataset beforehand.","category":"page"},{"location":"layers/mappings/#Functions-of-several-arguments","page":"Mappings","title":"Functions of several arguments","text":"","category":"section"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"In the case of functions of several arguments, such as isequal, the input variables must be passed as a Tuple.","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"accuracy = (:species, :predicted_species) => isequal => \"accuracy\"","category":"page"},{"location":"layers/mappings/#Partial-pair-syntax","page":"Mappings","title":"Partial pair syntax","text":"","category":"section"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"The \"triple-pair\" syntax is not necessary, one can also only pass the column name, a column name => function pair, or a column name => new label pair.","category":"page"},{"location":"layers/mappings/#Helper-functions","page":"Mappings","title":"Helper functions","text":"","category":"section"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"Some helper functions are provided, which can be used within the pair syntax to either rename and reorder unique values of a categorical column on the fly or to signal that a numerical column should be treated as categorical.","category":"page"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"renamer\nsorter\nnonnumeric","category":"page"},{"location":"layers/mappings/#AlgebraOfGraphics.renamer","page":"Mappings","title":"AlgebraOfGraphics.renamer","text":"renamer(arr::Union{AbstractArray, Tuple})\n\nUtility to rename a categorical variable, as in renamer([value1 => label1, value2 => label2]). The keys of all pairs should be all the unique values of the categorical variable and the values should be the corresponding labels. The order of arr is respected in the legend.\n\nExamples\n\njulia> r = renamer([\"class 1\" => \"Class One\", \"class 2\" => \"Class Two\"])\nAlgebraOfGraphics.Renamer{Vector{String}, Vector{String}}([\"class 1\", \"class 2\"], [\"Class One\", \"Class Two\"])\n\njulia> println(r(\"class 1\"))\nClass One\n\nAlternatively, a sequence of pair arguments may be passed.\n\njulia> r = renamer(\"class 1\" => \"Class One\", \"class 2\" => \"Class Two\")\nAlgebraOfGraphics.Renamer{Tuple{String, String}, Tuple{String, String}}((\"class 1\", \"class 2\"), (\"Class One\", \"Class Two\"))\n\njulia> println(r(\"class 1\"))\nClass One\n\nIf arr does not contain Pairs, elements of arr are assumed to be labels, and the unique values of the categorical variable are taken to be the indices of the array. This is particularly useful for dims mappings.\n\nExamples\n\njulia> r = renamer([\"Class One\", \"Class Two\"])\nAlgebraOfGraphics.Renamer{Nothing, Vector{String}}(nothing, [\"Class One\", \"Class Two\"])\n\njulia> println(r(2))\nClass Two\n\n\n\n\n\n","category":"function"},{"location":"layers/mappings/#AlgebraOfGraphics.sorter","page":"Mappings","title":"AlgebraOfGraphics.sorter","text":"sorter(ks...)\n\nUtility to reorder a categorical variable, as in sorter(\"low\", \"medium\", \"high\"). ks should include all the unique values of the categorical variable. The order of ks is respected in the legend.\n\n\n\n\n\n","category":"function"},{"location":"layers/mappings/#AlgebraOfGraphics.nonnumeric","page":"Mappings","title":"AlgebraOfGraphics.nonnumeric","text":"nonnumeric(x)\n\nTransform x into a non numeric type that is printed and sorted in the same way.\n\n\n\n\n\n","category":"function"},{"location":"layers/mappings/#Examples","page":"Mappings","title":"Examples","text":"","category":"section"},{"location":"layers/mappings/","page":"Mappings","title":"Mappings","text":"# column `train` has two unique values, `true` and `false`\n:train => renamer(true => \"training\", false => \"testing\") => \"Dataset\"\n# column `price` has three unique values, `\"low\"`, `\"medium\"`, and `\"high\"`\n:price => sorter(\"low\", \"medium\", \"high\")\n# column `age` is expressed in integers and we want to treat it as categorical\n:age => nonnumeric","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [AlgebraOfGraphics]","category":"page"},{"location":"API/#AlgebraOfGraphics.AxisEntries","page":"API","title":"AlgebraOfGraphics.AxisEntries","text":"AxisEntries(axis::Union{Axis, Nothing}, entries::Vector{Entry}, labels, scales)\n\nDefine all ingredients to make plots on an axis. Each scale can be either a CategoricalScale (for discrete collections), such as CategoricalScale([\"a\", \"b\"], [\"red\", \"blue\"]), or a function, such as log10. Other scales may be supported in the future.\n\n\n\n\n\n","category":"type"},{"location":"API/#AlgebraOfGraphics.density-Tuple{}","page":"API","title":"AlgebraOfGraphics.density","text":"density(; datalimits, npoints, kernel, bandwidth)\n\nFit a kernel density estimation of data. Here, datalimits specifies the range for which the density should be calculated, npoints is the number of points used by Makie to draw the line and kernel and bandwidth are forwarded to KernelDensity.kde.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.expectation-Tuple{}","page":"API","title":"AlgebraOfGraphics.expectation","text":"expectation(args...)\n\nCompute the expected value of the last argument conditioned on the preceding ones.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.frequency-Tuple{}","page":"API","title":"AlgebraOfGraphics.frequency","text":"frequency()\n\nCompute a frequency table of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.histogram-Tuple{}","page":"API","title":"AlgebraOfGraphics.histogram","text":"histogram(; bins=automatic, weights=automatic, normalization=:none)\n\nCompute a histogram. bins can be an Int to create that number of equal-width bins over the range of values. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting normalization. Possible values are:\n\n:pdf: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.\n:density: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1.\n:probability: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.\n:none: Do not normalize.\n\nWeighted data is supported via the keyword weights.\n\nnote: Note\nNormalizations are computed withing groups. For example, in the case of normalization=:pdf, sum of weights within each group will be equal to 1.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.iscontinuous-Tuple{Any}","page":"API","title":"AlgebraOfGraphics.iscontinuous","text":"iscontinuous(v)\n\nDetermine whether v should be treated as a continuous or categorical vector.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.linear-Tuple{}","page":"API","title":"AlgebraOfGraphics.linear","text":"linear(; interval)\n\nCompute a linear fit of y ~ 1 + x. An optional named mapping weights determines the weights. Use interval to specify what type of interval the shaded band should represent. Valid values of interval are :confidence delimiting the uncertainty of the predicted relationship, and :prediction delimiting estimated bounds for new data points.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.linesfill!-Tuple","page":"API","title":"AlgebraOfGraphics.linesfill!","text":"linesfill(xs, ys; lower, upper, kwargs...)\n\nLine plot with a shaded area between lower and upper. If lower and upper are not given, shaded area is between 0 and ys.\n\nAttributes\n\nAvailable attributes and their defaults for Combined{AlgebraOfGraphics.linesfill!, T} where T are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.linesfill-Tuple","page":"API","title":"AlgebraOfGraphics.linesfill","text":"linesfill(xs, ys; lower, upper, kwargs...)\n\nLine plot with a shaded area between lower and upper. If lower and upper are not given, shaded area is between 0 and ys.\n\nAttributes\n\nAvailable attributes and their defaults for Combined{AlgebraOfGraphics.linesfill, T} where T are: \n\n  color       :black\n  colormap    :viridis\n  colorrange  MakieCore.Automatic()\n  fillalpha   0.15\n  linestyle   \"nothing\"\n  linewidth   1.5\n  lower       MakieCore.Automatic()\n  upper       MakieCore.Automatic()\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.nonnumeric-Tuple{Any}","page":"API","title":"AlgebraOfGraphics.nonnumeric","text":"nonnumeric(x)\n\nTransform x into a non numeric type that is printed and sorted in the same way.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.plottypes_attributes-Tuple{Any}","page":"API","title":"AlgebraOfGraphics.plottypes_attributes","text":"plottypes_attributes(entries)\n\nReturn plottypes and relative attributes, as two vectors of the same length, for the given entries.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.renamer-Tuple{Union{Tuple, AbstractArray}}","page":"API","title":"AlgebraOfGraphics.renamer","text":"renamer(arr::Union{AbstractArray, Tuple})\n\nUtility to rename a categorical variable, as in renamer([value1 => label1, value2 => label2]). The keys of all pairs should be all the unique values of the categorical variable and the values should be the corresponding labels. The order of arr is respected in the legend.\n\nExamples\n\njulia> r = renamer([\"class 1\" => \"Class One\", \"class 2\" => \"Class Two\"])\nAlgebraOfGraphics.Renamer{Vector{String}, Vector{String}}([\"class 1\", \"class 2\"], [\"Class One\", \"Class Two\"])\n\njulia> println(r(\"class 1\"))\nClass One\n\nAlternatively, a sequence of pair arguments may be passed.\n\njulia> r = renamer(\"class 1\" => \"Class One\", \"class 2\" => \"Class Two\")\nAlgebraOfGraphics.Renamer{Tuple{String, String}, Tuple{String, String}}((\"class 1\", \"class 2\"), (\"Class One\", \"Class Two\"))\n\njulia> println(r(\"class 1\"))\nClass One\n\nIf arr does not contain Pairs, elements of arr are assumed to be labels, and the unique values of the categorical variable are taken to be the indices of the array. This is particularly useful for dims mappings.\n\nExamples\n\njulia> r = renamer([\"Class One\", \"Class Two\"])\nAlgebraOfGraphics.Renamer{Nothing, Vector{String}}(nothing, [\"Class One\", \"Class Two\"])\n\njulia> println(r(2))\nClass Two\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.smooth-Tuple{}","page":"API","title":"AlgebraOfGraphics.smooth","text":"smooth(span=0.75, degree=2)\n\nFit a loess model. span is the degree of smoothing, typically in [0,1]. Smaller values result in smaller local context in fitting. degree is the polynomial degree used in the loess model.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.sorter-Tuple","page":"API","title":"AlgebraOfGraphics.sorter","text":"sorter(ks...)\n\nUtility to reorder a categorical variable, as in sorter(\"low\", \"medium\", \"high\"). ks should include all the unique values of the categorical variable. The order of ks is respected in the legend.\n\n\n\n\n\n","category":"method"},{"location":"API/#AlgebraOfGraphics.to_entry-Tuple{AlgebraOfGraphics.Layer}","page":"API","title":"AlgebraOfGraphics.to_entry","text":"to_entry(layer::Layer)\n\nConvert layer to equivalent entry, excluding transformations.\n\n\n\n\n\n","category":"method"},{"location":"layers/draw/#Drawing-Layers","page":"Drawing Layers","title":"Drawing Layers","text":"","category":"section"},{"location":"layers/draw/","page":"Drawing Layers","title":"Drawing Layers","text":"A Layers object can be plotted using the function draw.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AlgebraOfGraphics","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AlgebraOfGraphics defines a language for data visualization. It is based on a few simple building blocks that can be combined using + and *.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package can be installed typing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"AlgebraOfGraphics\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Tutorial to get started.","category":"page"}]
}
