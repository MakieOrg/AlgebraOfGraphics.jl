var documenterSearchIndex = {"docs":
[{"location":"analyses/#Analyses","page":"Analyses","title":"Analyses","text":"","category":"section"},{"location":"analyses/","page":"Analyses","title":"Analyses","text":"AlgebraOfGraphics.linear\nAlgebraOfGraphics.smooth\nAlgebraOfGraphics.density\nAlgebraOfGraphics.histogram\nAlgebraOfGraphics.frequency\nAlgebraOfGraphics.reducer","category":"page"},{"location":"analyses/#AlgebraOfGraphics.linear","page":"Analyses","title":"AlgebraOfGraphics.linear","text":"linear(x, y; wts = similar(x, 0), interval = length(wts) > 0 ? nothing : :confidence)\n\nCompute a linear fit of y ~ 1 + x. Weighted data is supported via the keyword wts. Use interval to specify what type of interval the shaded band should represent. Valid values of interval are :confidence delimiting the uncertainty of the predicted relationship, and :prediction delimiting estimated bounds for new data points.\n\n\n\n\n\n","category":"constant"},{"location":"analyses/#AlgebraOfGraphics.smooth","page":"Analyses","title":"AlgebraOfGraphics.smooth","text":"smooth(x, y, span=0.75, degreee=2)\n\nFit a loess model. span is the degree of smoothing, typically in [0,1]. Smaller values result in smaller local context in fitting. degree is the polynomial degree used in the loess model.\n\n\n\n\n\n","category":"constant"},{"location":"analyses/#AlgebraOfGraphics.density","page":"Analyses","title":"AlgebraOfGraphics.density","text":"density(data...; trim = false, boundary, npoints, kernel, bandwidth)\n\nFit a kernel density estimation of data. Only 1D and 2D are supported so far. The optional keyword arguments are\n\nboundary: the lower and upper limits of the kde as a tuple. Due to the fourier transforms used internally, there should be sufficient spacing to prevent wrap-around at the boundaries.\nnpoints: the number of interpolation points to use. The function uses fast Fourier transforms (FFTs) internally, so for optimal efficiency this should be a power of 2 (default = 2048).\nkernel: the distributional family from Distributions.jl to use as the kernel (default = Normal). To add your own kernel, extend the internal kernel_dist function.\nbandwidth: the bandwidth of the kernel. Default is to use Silverman's rule.\n\n\n\n\n\n","category":"constant"},{"location":"analyses/#AlgebraOfGraphics.histogram","page":"Analyses","title":"AlgebraOfGraphics.histogram","text":"histogram(data...; bins = automatic, wts = automatic, normalization = :none)\n\nPlot a histogram of values. bins can be an Int to create that number of equal-width bins over the range of values. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting normalization. Possible values are:\n\n:pdf: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.\n:density: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1.\n:probability: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.\n:none: Do not normalize.\n\nWeighted data is supported via the keyword wts.\n\n\n\n\n\n","category":"constant"},{"location":"analyses/#AlgebraOfGraphics.frequency","page":"Analyses","title":"AlgebraOfGraphics.frequency","text":"frequency(data...)\n\nCompute a frequency table of the arguments.\n\n\n\n\n\n","category":"constant"},{"location":"analyses/#AlgebraOfGraphics.reducer","page":"Analyses","title":"AlgebraOfGraphics.reducer","text":"reducer(args...; agg=Mean())\n\nReduce the last argument conditioned on the preceding ones using the online statistic or binary function agg.\n\n\n\n\n\n","category":"constant"},{"location":"analyses/","page":"Analyses","title":"Analyses","text":"note: Note\nAnalyses are currently not exported. In the future they may be exported or be in their own module.","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/internals.jl\"","category":"page"},{"location":"generated/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"AlgebraOfGraphics is based on contexts, which can be extended. A context, together with a named tuple (used for x, y axes or attributes in the plot) forms a Mapping. Each Mapping can actually encode many traces, encoded as a list of NamedTuple => Mapping pairs, accessible using pairs(st::Mapping).","category":"page"},{"location":"generated/internals/#Contexts","page":"Internals","title":"Contexts","text":"","category":"section"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"The DataContext is invoked with data(df), where df respects the Tables.jl interface.","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"using RDatasets: dataset\nusing AlgebraOfGraphics\nmpg = dataset(\"ggplot2\", \"mpg\")\nt = data(mpg)\nst = mapping(:Cyl, color = :Year => categorical)\n\npairs(t * st)","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"In the dims(i) context, all variables in mapping are sliced along the i-th dimension. The resulting arrays of arrays broadcasted to a common shape, and each \"inner array\" corresponds to a separate trace. The syntax dims exists to allow setting discrete attributes variables that only vary with one of the dimensions.","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"d = dims(1) * mapping(rand(5, 3, 2), rand(5, 3), color = dims(2))\npairs(d)","category":"page"},{"location":"generated/internals/#Combining-mappings-and-contexts","page":"Internals","title":"Combining mappings and contexts","text":"","category":"section"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"All outputs of mapping, data, and dims inherit can be combined using + (adding a new layer), or * (merge information in existing layer).","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"using CairoMakie\nmpg1 = copy(mpg)\nmpg1.Displ = mpg.Displ .* 0.1\nts = data(mpg) * visual(markersize = 5) + data(mpg1) * visual(markersize=10)\nsl = ts * mapping(:Hwy, :Displ, color = :Cyl => categorical)","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"The result can then be plotted using the draw function:","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"sl * visual(Scatter) |> draw\nAbstractPlotting.save(\"combine.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"(Image: )","category":"page"},{"location":"generated/internals/#Implementing-a-new-context","page":"Internals","title":"Implementing a new context","text":"","category":"section"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"To implement a new context, one can overload:","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"AlgebraOfGraphics._merge(c::MyContext, s1::Mapping, s2::Mapping), to allow applying mapping to MyContext,\nAlgebraOfGraphics._pairs(c::MyContext, s::Mapping), which must iterates group::NamedTuple => mapping::Mapping pairs.","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"See example implementation in the context file.","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"generated/internals/","page":"Internals","title":"Internals","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/statistics.jl\"","category":"page"},{"location":"generated/statistics/#Statistical-plots","page":"Statistical plots","title":"Statistical plots","text":"","category":"section"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"Statistical plots are supported automatically, provided that they are implemented in Makie. Integration with the styling framework should also happen automatically. Some particular statistical plots have specific keyword options that can be applied in mapping, such as dodge (for boxplot and violin) or side (for violin).","category":"page"},{"location":"generated/statistics/#Examples","page":"Statistical plots","title":"Examples","text":"","category":"section"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"using RDatasets: dataset\nusing AlgebraOfGraphics, CairoMakie\nmpg = dataset(\"ggplot2\", \"mpg\");\nmpg.IsAudi = mpg.Manufacturer .== \"audi\"\ngeom = visual(BoxPlot, layout_x = 1) + visual(Violin, layout_x = 2)\ndata(mpg) *\n    mapping(:Cyl => categorical, :Hwy) *\n    mapping(dodge = :IsAudi => categorical, color = :IsAudi => categorical) *\n    geom |> draw\nAbstractPlotting.save(\"boxplot.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"(Image: )","category":"page"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"data(mpg) *\n    mapping(:Cyl => categorical, :Hwy) *\n    mapping(side = :IsAudi => categorical, color = :IsAudi => categorical) *\n    visual(Violin) |> draw\nAbstractPlotting.save(\"violin.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"(Image: )","category":"page"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"","category":"page"},{"location":"generated/statistics/","page":"Statistical plots","title":"Statistical plots","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we will see what are the basic building blocks of AlgebraOfGraphics, and how to combine them to create complex plots based on tables or other formats.","category":"page"},{"location":"generated/tutorial/#Basic-building-blocks","page":"Tutorial","title":"Basic building blocks","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The most important functions are mapping, and visual. mapping determines the mappings from data to plot. Its positional arguments correspond to the x, y or z axes of the plot, whereas the keyword arguments correspond to plot attributes that can vary continuously or discretely, such as color or markersize. Variables in mapping  are split according to the categorical attributes in it, and then converted to plot attributes using a default palette. Finally visual can be used to give data-independent visual information about the plot (plotting function or attributes).","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"mapping and visual work in various context. In the following we will explore DataContext, which is introduced doing data(df) for any tabular mapping structure df. In this context, mapping accepts symbols and integers, which correspond to columns of the data.","category":"page"},{"location":"generated/tutorial/#Operations","page":"Tutorial","title":"Operations","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The outputs of mapping, visual, and data can be combined with + or *, to generate an AlgebraicList object, which can then be plotted using the function draw. The actual drawing is done by AbstractPlotting.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The operation + is used to create separate layer. a + b has as many layers as la + lb, where la and lb are the number of layers in a and b respectively.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The operation a * b create la * lb layers, where la and lb are the number of layers in a and b respectively. Each layer of a * b contains the combined information of the corresponding layer in a and the corresponding layer in b. In simple cases, however, both a and b will only have one layer, and a * b simply combines the information.","category":"page"},{"location":"generated/tutorial/#Working-with-tables","page":"Tutorial","title":"Working with tables","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using RDatasets: dataset\nusing AlgebraOfGraphics, CairoMakie\nmpg = dataset(\"ggplot2\", \"mpg\");\ncols = mapping(:Displ, :Hwy);\ngrp = mapping(color = :Cyl => categorical);\nscat = visual(Scatter)\npipeline = cols * scat\ndata(mpg) * pipeline |> draw\nAbstractPlotting.save(\"scatter.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Now let's simply add grp to the pipeline to color according to :Cyl.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"data(mpg) * grp * pipeline |> draw\nAbstractPlotting.save(\"grouped_scatter.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: ) Traces can be added together with +.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using AlgebraOfGraphics: linear\npipenew = cols * (scat + linear)\ndata(mpg) * pipenew |> draw\nAbstractPlotting.save(\"linear.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: ) We can put grouping in the pipeline (we get a warning because of a degenerate group).","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"data(mpg) * grp * pipenew |> draw\nAbstractPlotting.save(\"grouped_linear.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: ) This is a more complex example, where we split the scatter plot, but do the linear regression with all the data. Moreover, we pass weights to linear to compute the regression line with weighted least squares.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"different_grouping = grp * scat + linear * mapping(wts=:Hwy)\ndata(mpg) * cols * different_grouping |> draw\nAbstractPlotting.save(\"semi_grouped.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Different analyses are also possible, always with the same syntax:","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using AlgebraOfGraphics: smooth, density, frequency, reducer\ndata(mpg) * cols * grp * (scat + smooth(span = 0.8)) |> draw\nAbstractPlotting.save(\"loess.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"data(mpg) * cols * density |> draw\nAbstractPlotting.save(\"density.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"data(mpg) * mapping(:Cyl => categorical) * frequency |> draw\nAbstractPlotting.save(\"frequency.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"data(mpg) * mapping(:Cty, :Hwy) * reducer(agg = +) |> draw\nAbstractPlotting.save(\"reducer.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also add visual information that only makes sense in one recipe (e.g. markersize) by multiplying them:","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"newmapping = mapping(markersize = :Cyl) * visual(markersize = (0.1, 5))\ndata(mpg) * cols * (scat * newmapping + smooth(span = 0.8)) |> draw\nAbstractPlotting.save(\"loess_markersize.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#Layout","page":"Tutorial","title":"Layout","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Thanks to the MakieLayout package it is possible to create plots where categorical variables inform the layout.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"iris = dataset(\"datasets\", \"iris\")\ncols = mapping(:SepalLength, :SepalWidth)\ngrp = mapping(layout_x = :Species)\ngeom = visual(Scatter) + linear\ndata(iris) * cols * grp * geom |> draw\nAbstractPlotting.save(\"layout.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"iris = dataset(\"datasets\", \"iris\")\ncols = mapping(:SepalLength)\ngrp = mapping(layout_x = :Species)\ngeom = AlgebraOfGraphics.histogram\ndata(iris) * cols * grp * geom |> draw\nAbstractPlotting.save(\"hist.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#Non-tabular-mapping-(slicing-context)","page":"Tutorial","title":"Non tabular mapping (slicing context)","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The framework is not specific to tables, but can be used in different contexts. For instance, dims() introduces a context where each entry of the array corresponds to a trace.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"x = [-pi..0, 0..pi]\ny = [sin cos] # We use broadcasting semantics on `tuple.(x, y)`.\ndims() * mapping(x, y, color = dims(1), linestyle = dims(2)) |> draw\nAbstractPlotting.save(\"functions.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using Distributions\ndistributions = InverseGaussian.(1:4, [6 10])\ndims() * mapping(fill(0..5), distributions, color = dims(1), linestyle = dims(2)) |> draw\nAbstractPlotting.save(\"distributions.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"More generally, one can pass arguments to dims to implement the \"slices are series\" approach.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"s = dims(1) * mapping(rand(50, 3), rand(50, 3, 2))\ngrp = mapping(color = dims(2), layout_x = dims(3))\ns * grp * visual(Scatter) |> draw\nAbstractPlotting.save(\"arrays.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"This approach can be used in combination with the tabular context to work with \"wide\" data, where grouping is done by column.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"iris = dataset(\"datasets\", \"iris\")\ncols = mapping([:SepalLength, :SepalWidth], [:PetalLength :PetalWidth])\ngrp = mapping(layout_x = dims(1), layout_y = dims(2), color = :Species)\ngeom = visual(Scatter) + linear\ndata(iris) * cols * grp * geom |> draw\nAbstractPlotting.save(\"layout_wide.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"AlgebraOfGraphics defines a \"plotting package agnostic\" algebra of graphics based on a few simple building blocks that can be combined using + and *.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package can be installed typing","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@v1.4) pkg> add AlgebraOfGraphics","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"in the Pkg REPL.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See Tutorial for examples on how to use it. Internals gives more details about the internal workings of AlgebraOfGraphics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you prefer a more visual, interactive workflow, an example GUI is available in the examples folder.","category":"page"}]
}
